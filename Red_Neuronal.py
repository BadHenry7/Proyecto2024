# -*- coding: utf-8 -*-
"""Prueba 1 de red

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ifVzYoi7iw1Y1-XHsPwTJHeOCo8vrfsr

Hola mano
"""

import keras
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.utils import to_categorical

# Usamos panda para cargar el dataset para estudiarlo
data = pd.read_csv('Final_Augmented_dataset_Diseases_and_Symptoms.csv', sep=';')
data.head()

data.info()

print(data.columns)

# Separar las características (síntomas) y el objetivo (enfermedades)
#X =data.drop(columns = ['diseases'], axis=1)
# Copiar la columna a una variable
y = data['diseases'].copy()

# Eliminar la columna del DataFrame
#X=data.drop('diseases', axis=1, inplace=True)
X=data.drop(columns=['diseases'], axis=1)  # Características (síntomas)
#X = data.drop(columns='diseases') # Características (síntomas), esto borra el diseases dejando solamente los sintomas

y

print(data.columns.tolist())  # Muestra los nombres de todas las columnas como una lista

# Verificar los valores únicos en la columna 'diseases'
print(data['diseases'].unique())

print("-----------------------------YOU RIGHT HERE---------------------------------------")

# Ahora, convertir la columna de enfermedades a valores numéricos
le = LabelEncoder()
y = le.fit_transform(data['diseases'])
y = to_categorical(y)  # Convertir las variables objetivo en formato categórico

print(y)

#le = LabelEncoder()
#Convertir los datos escritos de y como las enfermedades, en valores numericos como por ejemplo 1,2,3,4 para el caso de 4 enfermedades distintas
#y = le.fit_transform(data['diseases'])
#y = to_categorical(y)  # Convertir las variables objetivas (las enfermedades a datos para su clasificacion)

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Escalar las características
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
print(X_train)
print("-------------------------------------------")
print(X_test)

# Construir la red neuronal
model = Sequential()

# Creacion de las capas ocultas :D
#1
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dropout(0.20))  # Regularización

#2
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.20))  # Regularización

#3
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.20))  # Regularización

#4
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.20))  # Regularización

#5
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.20))  # Regularización

model.add(Dense(y.shape[1], activation='softmax'))  # Capa de salida para múltiples clases

# Compilar el modelo
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
#el loss de categorical_croseentropy nos sive porque nuestro problema es de clasificacion en vez de regresion como habia dicho xd
#entonces al no ser de regresion el mse o mean_square_error ya no es necesario y solamente obstruiria por ahora ando terminando de comprender correctamente todo para
#para poder graficarlo y tener un mejor entendimiento de la red.

# Entrenar el modelo
print("Comenzando a entrenamiento....")
historial = model.fit(X_train, y_train, epochs=100, batch_size=128, validation_split=0.2)
# Pusimos el batch size para que, joa mejor lo pongo en otro cuadro
print("Modelo entrenado ;3 ponlo aprueba")

"""El batch size es de 128 porque![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfAAAAA9CAYAAABSrTs4AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAB22SURBVHhe7d0HlCRFGcDxRjCLOWE4BcWACRXTGRAMiCgeGFBRQE8wIKKgiKjAnYCcIEFQOMR0eCQxoIBZoiKgiBkRFBOYMGeUtn91U9Db1zPTG25vZ/f7vzdvZ3t6uquqa+qLVbVGWVEEQRAEQTBS3Kj3NwiCIAiCESIEeBAEQRCMICHAgyAIgmAECQEeBEEQBCNICPAgCIIgGEFCgAdBEATBCBICfI5gtuBf/vKX4p///GfvSBAEQTDKzBkB/pvf/KY466yzev+N5dxzzy1+8IMfJOFG0P3pT38qvvKVrxRXXHFF74zu/OEPfyiWL19eHHroocUpp5xS/O53v+t90p+vfe1rxfvf//7efytwnX333be46KKL0vvmazyC+DOf+Uxx73vfu7jHPe6R3gdBEASjz6wW4L/4xS+SwNptt92KTTfdtLjgggt6n9zA//73v+LMM88sHvvYxxZ3uctditvc5jbFvHnzivPOO69YZ511emd14+tf/3rxrne9q5g/f37x8pe/vPjb3/5WPOtZzyq++tWv9s5YGYoFYU8o17nmmmuKL37xi8VTnvKUJHybL2XuyrOf/eykJCjXRPn73/9efP7zny/+85//9I4EQRAEq5NZb4Hf4Q53KF7xilcU973vfXtHxrLmmmsWt7zlLYutttoqCfndd9+9+NKXvlS87W1vK25xi1v0zhoOwXbqqacWF154YXHdddclRWCzzTYr7njHOxZLly5N7usm//3vf4uPfvSjrQKeAN9ggw2KRYsWjXlRDHbcccfiyU9+cu/Mbtz85jdPr4lCwaAAUXiCIAiC1c+sFuD3vOc9k9V517vetbjRjfpX9WY3u1kS2J/61KeKffbZp3j0ox898Px+3PjGN04WNWs1/7/WWmsldzeh3uT8888v1l577eJRj3pU78gNXHXVVcXOO+9cvOENb7j+9cpXvrK4/e1vX+y6667jUi6mgh//+MfFH//4x95/QRAEwepm1lvg08VNbnKTpAQQyg95yEPSsZ/97GfFD3/4w+SeJ6jrEPTf+MY3imc+85mtysJDH/rQMV4Dsfnjjz8+eQm4+IdBYSB0xfeFEtoUCPz1r39N7vVly5alc/3f5LLLLive8573FP/+97+TEGeNN13pvAnf/e53ixNPPDGFEtpi9PIBeDfOOOOM4sorryy+973vhUUfBEEwQUKAVxCOX/7yl5Or/TnPeU7xmte8ZkIJbIT4rW9962KNNdYofv/73xcf+chHkqt7++23T676DGHH3U5497OkCe9b3epWvf+K5L4WU6cMDMO9X/3qV6f7E5Df/OY3k/v9l7/8Ze+MFfz85z8vnvvc56YEPrF6AnqbbbYZ49LXDjwT//jHP4rLL788ufxdl1KQ8V6b/fSnPy2e+tSnputw83/729/unVEUn/3sZ4tjjjkmKSYbbbRR8elPf7r4wAc+EDH1IAiCCRICvIJwut3tbpcEDMH6vOc9r9hpp52KH/3oR70zuiODfZdddikWLlyYrrvnnnumOHwdFqpj97vf/XpHBsMqPvnkk1NMnUt+EO65ePHi4u53v3vKYqdALFiwoLUcXP0s6j//+c/JNS9hjlLx7ne/O8XgcZ/73CfVRzzey3vufMehvjwPQhWS5cT8N9544xSrf8tb3pKUhH/961/J8laWO9/5zum1ww47pGS8IAiCYGKEAK8glJ7//Odf78pmJbJ+TQMbr4v3tre9bXHEEUckRcB1t9122+K4445LVjd++9vfpkS3zTffPFnqXWBBE6iE8jC+853vpHI/8YlPHCPs25LYHvCAB6RsdjF1KA/hyr3fzIrvB/e7sMGGG244pj7yDygGBLd25Z044IAD0qyAX/3qV6kslCT5B0EQBMH4CQFeQZjU49Dee11yySWtMeGusLC5i5csWZLiw5QBAmyLLbbonITGHS1mvN5666Vs+WGweLnau2ScE7is46OOOiopMDLwTV0bD2L8d7rTnfqW7fvf/36KvwtPSOqj0DzwgQ8snva0p6UYeFclJgiCIBjLnBfgX/jCF5KgPf3003tHboDV3C/5qwnXtUQwFq2YOghRi6eIEUsoowxQCt785jcnt7bXdtttV1x88cXJRe7/ZjlY7N/61reSpVqPo08F7mv6HOtYbJvrnGAdBgVBPBzKpe4UjTbkBBDcXO48A7wJQhVCFm9961uTwhEEQRCMnzkvwMVwCaQ6hLbXve51rzGWrJhxniLWhOv6ta99bcrWztOtZGJfffXV6T2XfHavSwrLL0L/EY94RPGCF7wg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) actualizara 120 veces los pesos de manera simultanea, hize una simulacion con chatgpt y para mi equipo es un punto intermedio, aunque como estamos en google colab depronto podramos aumentar el tamaño del batch ?, no se que opinen,

Por sio acaso
epoca (epochs): Una pasada completa por todo el dataset.

Batch: La cantidad de datos que el modelo procesa antes de actualizar los pesos.

Encontre la cosa esa que grafica la funcion de la red :DDDD
"""

import matplotlib.pyplot as plt
plt.xlabel("# de epoca (son los intentos que hizo)")
plt.ylabel("margen de perdida o error")
plt.plot(historial.history["loss"])

plt.plot(historial.history['accuracy'], label='Train Accuracy')
plt.plot(historial.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')

# Evaluar el modelo
loss, accuracy = model.evaluate(X_test, y_test)
print(f'Loss: {loss}, Accuracy: {accuracy}')

from math import e

data = pd.read_csv('Final_Augmented_dataset_Diseases_and_Symptoms.csv', sep=';')


# Lista de todos los síntomas, usando el drop data para tomar los necesarios
sintomas = data.drop(columns=['diseases'], axis=1).columns.tolist()
print(sintomas)
print("------------------------1---------------------------")
#Lista de enfermedades
enfermedades = data['diseases'].unique().tolist()
print(enfermedades)
print("------------------------2---------------------------")

#Aca tomamos los sintomas y verificamos
sintomas_paciente = ["fever","diarrhea","vomit","lower abdominal pain"]

# Crear un vector de entrada con 0's del tamaño de `all_symptoms`
vector_entrada_dato = [1 if dato in sintomas_paciente else 0 for dato in sintomas]

# Asegúrate de que sea un array de numpy y tenga la forma correcta para la red neuronal
vector_entrada_dato = np.array(vector_entrada_dato).reshape(1, -1)

# Hacer la predicción
result = model.predict(vector_entrada_dato)
predicted_class = np.argmax(result)  # Si necesitas la clase predicha

print(f"----->: {result}")
print(f"Su enfermedad es: {enfermedades[predicted_class]}")